var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
import { Injectable, Injector, Inject, SecurityContext } from '@angular/core';
import { Overlay } from '../overlay/overlay';
import { ComponentPortal } from '../portal/portal';
import { ToastPackage } from './toastr-config';
import { ToastInjector, ToastRef } from './toast-injector';
import { TOAST_CONFIG } from './toast-token';
import { Toast } from './toast-component';
import { DomSanitizer } from '@angular/platform-browser';
var ToastrService = (function () {
    function ToastrService(toastrConfig, overlay, _injector, sanitizer) {
        this.toastrConfig = toastrConfig;
        this.overlay = overlay;
        this._injector = _injector;
        this.sanitizer = sanitizer;
        this.index = 0;
        this.currentlyActive = 0;
        this.toasts = [];
        function use(source, defaultValue) {
            return toastrConfig && source !== undefined ? source : defaultValue;
        }
        this.toastrConfig = this.applyConfig(toastrConfig);
        // Global
        this.toastrConfig.maxOpened = use(this.toastrConfig.maxOpened, 0);
        this.toastrConfig.autoDismiss = use(this.toastrConfig.autoDismiss, false);
        this.toastrConfig.newestOnTop = use(this.toastrConfig.newestOnTop, true);
        this.toastrConfig.preventDuplicates = use(this.toastrConfig.preventDuplicates, false);
        if (!this.toastrConfig.iconClasses) {
            this.toastrConfig.iconClasses = {};
        }
        this.toastrConfig.iconClasses.error = this.toastrConfig.iconClasses.error || 'toast-error';
        this.toastrConfig.iconClasses.info = this.toastrConfig.iconClasses.info || 'toast-info';
        this.toastrConfig.iconClasses.success = this.toastrConfig.iconClasses.success || 'toast-success';
        this.toastrConfig.iconClasses.warning = this.toastrConfig.iconClasses.warning || 'toast-warning';
        // Individual
        this.toastrConfig.timeOut = use(this.toastrConfig.timeOut, 5000);
        this.toastrConfig.closeButton = use(this.toastrConfig.closeButton, false);
        this.toastrConfig.extendedTimeOut = use(this.toastrConfig.extendedTimeOut, 1000);
        this.toastrConfig.progressBar = use(this.toastrConfig.progressBar, false);
        this.toastrConfig.enableHtml = use(this.toastrConfig.enableHtml, false);
        this.toastrConfig.toastClass = use(this.toastrConfig.toastClass, 'toast');
        this.toastrConfig.positionClass = use(this.toastrConfig.positionClass, 'toast-top-right');
        this.toastrConfig.titleClass = use(this.toastrConfig.titleClass, 'toast-title');
        this.toastrConfig.messageClass = use(this.toastrConfig.messageClass, 'toast-message');
        this.toastrConfig.tapToDismiss = use(this.toastrConfig.tapToDismiss, true);
        this.toastrConfig.toastComponent = use(this.toastrConfig.toastComponent, Toast);
        this.toastrConfig.onActivateTick = use(this.toastrConfig.onActivateTick, false);
    }
    /** show toast */
    ToastrService.prototype.show = function (message, title, override, type) {
        if (type === void 0) { type = ''; }
        return this._buildNotification(type, message, title, this.applyConfig(override));
    };
    /** show successful toast */
    ToastrService.prototype.success = function (message, title, override) {
        var type = this.toastrConfig.iconClasses.success || '';
        return this._buildNotification(type, message, title, this.applyConfig(override));
    };
    /** show error toast */
    ToastrService.prototype.error = function (message, title, override) {
        var type = this.toastrConfig.iconClasses.error || '';
        return this._buildNotification(type, message, title, this.applyConfig(override));
    };
    /** show info toast */
    ToastrService.prototype.info = function (message, title, override) {
        var type = this.toastrConfig.iconClasses.info || '';
        return this._buildNotification(type, message, title, this.applyConfig(override));
    };
    /** show warning toast */
    ToastrService.prototype.warning = function (message, title, override) {
        var type = this.toastrConfig.iconClasses.warning || '';
        return this._buildNotification(type, message, title, this.applyConfig(override));
    };
    /**
     * Remove all or a single toast by id
     */
    ToastrService.prototype.clear = function (toastId) {
        // Call every toastRef manualClose function
        for (var _i = 0, _a = this.toasts; _i < _a.length; _i++) {
            var toast = _a[_i];
            if (toastId !== undefined) {
                if (toast.toastId === toastId) {
                    toast.toastRef.manualClose();
                    return;
                }
            }
            else {
                toast.toastRef.manualClose();
            }
        }
    };
    /**
     * Remove and destroy a single toast by id
     */
    ToastrService.prototype.remove = function (toastId) {
        var found = this._findToast(toastId);
        if (!found) {
            return false;
        }
        found.activeToast.toastRef.close();
        this.toasts.splice(found.index, 1);
        this.currentlyActive = this.currentlyActive - 1;
        if (!this.toastrConfig.maxOpened || !this.toasts.length) {
            return false;
        }
        if (this.currentlyActive <= +this.toastrConfig.maxOpened && this.toasts[this.currentlyActive]) {
            var p = this.toasts[this.currentlyActive].toastRef;
            if (!p.isInactive()) {
                this.currentlyActive = this.currentlyActive + 1;
                p.activate();
            }
        }
        return true;
    };
    /**
     * Determines if toast message is already shown
     */
    ToastrService.prototype.isDuplicate = function (message) {
        for (var i = 0; i < this.toasts.length; i++) {
            if (this.toasts[i].message === message) {
                return true;
            }
        }
        return false;
    };
    /** create a clone of global config and apply individual settings */
    ToastrService.prototype.applyConfig = function (override) {
        if (override === void 0) { override = {}; }
        function use(source, defaultValue) {
            return override && source !== undefined ? source : defaultValue;
        }
        var current = __assign({}, this.toastrConfig);
        current.closeButton = use(override.closeButton, current.closeButton);
        current.extendedTimeOut = use(override.extendedTimeOut, current.extendedTimeOut);
        current.progressBar = use(override.progressBar, current.progressBar);
        current.timeOut = use(override.timeOut, current.timeOut);
        current.enableHtml = use(override.enableHtml, current.enableHtml);
        current.toastClass = use(override.toastClass, current.toastClass);
        current.positionClass = use(override.positionClass, current.positionClass);
        current.titleClass = use(override.titleClass, current.titleClass);
        current.messageClass = use(override.messageClass, current.messageClass);
        current.tapToDismiss = use(override.tapToDismiss, current.tapToDismiss);
        current.toastComponent = use(override.toastComponent, current.toastComponent);
        current.onActivateTick = use(override.onActivateTick, current.onActivateTick);
        return current;
    };
    /**
     * Find toast object by id
     */
    ToastrService.prototype._findToast = function (toastId) {
        for (var i = 0; i < this.toasts.length; i++) {
            if (this.toasts[i].toastId === toastId) {
                return { index: i, activeToast: this.toasts[i] };
            }
        }
        return null;
    };
    /**
     * Creates and attaches toast data to component
     * returns null if toast is duplicate and preventDuplicates == True
     */
    ToastrService.prototype._buildNotification = function (toastType, message, title, config) {
        var _this = this;
        if (!config.toastComponent) {
            throw new Error('toastComponent required');
        }
        // max opened and auto dismiss = true
        if (message && this.toastrConfig.preventDuplicates && this.isDuplicate(message)) {
            return null;
        }
        this.previousToastMessage = message;
        var keepInactive = false;
        if (this.toastrConfig.maxOpened && this.currentlyActive >= this.toastrConfig.maxOpened) {
            keepInactive = true;
            if (this.toastrConfig.autoDismiss) {
                this.clear(this.toasts[this.toasts.length - 1].toastId);
            }
        }
        var overlayRef = this.overlay.create(config.positionClass, this.overlayContainer);
        this.index = this.index + 1;
        var sanitizedMessage = message;
        if (message && config.enableHtml) {
            sanitizedMessage = this.sanitizer.sanitize(SecurityContext.HTML, message);
        }
        var toastRef = new ToastRef(overlayRef);
        var toastPackage = new ToastPackage(this.index, config, sanitizedMessage, title, toastType, toastRef);
        var ins = {
            toastId: this.index,
            message: message,
            toastRef: toastRef,
            onShown: toastRef.afterActivate(),
            onHidden: toastRef.afterActivate(),
            onTap: toastPackage.onTap(),
            onAction: toastPackage.onAction(),
        };
        var toastInjector = new ToastInjector(toastPackage, this._injector);
        var component = new ComponentPortal(config.toastComponent, toastInjector);
        ins.portal = overlayRef.attach(component, this.toastrConfig.newestOnTop);
        if (!keepInactive) {
            setTimeout(function () {
                ins.toastRef.activate();
                _this.currentlyActive = _this.currentlyActive + 1;
            });
        }
        this.toasts.push(ins);
        return ins;
    };
    ToastrService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    ToastrService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [TOAST_CONFIG,] },] },
        { type: Overlay, },
        { type: Injector, },
        { type: DomSanitizer, },
    ]; };
    return ToastrService;
}());
export { ToastrService };
//# sourceMappingURL=toastr-service.js.map