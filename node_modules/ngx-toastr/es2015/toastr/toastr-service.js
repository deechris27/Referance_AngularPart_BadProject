import { Injectable, Injector, Inject, SecurityContext } from '@angular/core';
import { Overlay } from '../overlay/overlay';
import { ComponentPortal } from '../portal/portal';
import { ToastPackage } from './toastr-config';
import { ToastInjector, ToastRef } from './toast-injector';
import { TOAST_CONFIG } from './toast-token';
import { Toast } from './toast-component';
import { DomSanitizer } from '@angular/platform-browser';
export class ToastrService {
    constructor(toastrConfig, overlay, _injector, sanitizer) {
        this.toastrConfig = toastrConfig;
        this.overlay = overlay;
        this._injector = _injector;
        this.sanitizer = sanitizer;
        this.index = 0;
        this.currentlyActive = 0;
        this.toasts = [];
        function use(source, defaultValue) {
            return toastrConfig && source !== undefined ? source : defaultValue;
        }
        this.toastrConfig = this.applyConfig(toastrConfig);
        this.toastrConfig.maxOpened = use(this.toastrConfig.maxOpened, 0);
        this.toastrConfig.autoDismiss = use(this.toastrConfig.autoDismiss, false);
        this.toastrConfig.newestOnTop = use(this.toastrConfig.newestOnTop, true);
        this.toastrConfig.preventDuplicates = use(this.toastrConfig.preventDuplicates, false);
        if (!this.toastrConfig.iconClasses) {
            this.toastrConfig.iconClasses = {};
        }
        this.toastrConfig.iconClasses.error = this.toastrConfig.iconClasses.error || 'toast-error';
        this.toastrConfig.iconClasses.info = this.toastrConfig.iconClasses.info || 'toast-info';
        this.toastrConfig.iconClasses.success = this.toastrConfig.iconClasses.success || 'toast-success';
        this.toastrConfig.iconClasses.warning = this.toastrConfig.iconClasses.warning || 'toast-warning';
        this.toastrConfig.timeOut = use(this.toastrConfig.timeOut, 5000);
        this.toastrConfig.closeButton = use(this.toastrConfig.closeButton, false);
        this.toastrConfig.extendedTimeOut = use(this.toastrConfig.extendedTimeOut, 1000);
        this.toastrConfig.progressBar = use(this.toastrConfig.progressBar, false);
        this.toastrConfig.enableHtml = use(this.toastrConfig.enableHtml, false);
        this.toastrConfig.toastClass = use(this.toastrConfig.toastClass, 'toast');
        this.toastrConfig.positionClass = use(this.toastrConfig.positionClass, 'toast-top-right');
        this.toastrConfig.titleClass = use(this.toastrConfig.titleClass, 'toast-title');
        this.toastrConfig.messageClass = use(this.toastrConfig.messageClass, 'toast-message');
        this.toastrConfig.tapToDismiss = use(this.toastrConfig.tapToDismiss, true);
        this.toastrConfig.toastComponent = use(this.toastrConfig.toastComponent, Toast);
        this.toastrConfig.onActivateTick = use(this.toastrConfig.onActivateTick, false);
    }
    show(message, title, override, type = '') {
        return this._buildNotification(type, message, title, this.applyConfig(override));
    }
    success(message, title, override) {
        const type = this.toastrConfig.iconClasses.success || '';
        return this._buildNotification(type, message, title, this.applyConfig(override));
    }
    error(message, title, override) {
        const type = this.toastrConfig.iconClasses.error || '';
        return this._buildNotification(type, message, title, this.applyConfig(override));
    }
    info(message, title, override) {
        const type = this.toastrConfig.iconClasses.info || '';
        return this._buildNotification(type, message, title, this.applyConfig(override));
    }
    warning(message, title, override) {
        const type = this.toastrConfig.iconClasses.warning || '';
        return this._buildNotification(type, message, title, this.applyConfig(override));
    }
    clear(toastId) {
        for (const toast of this.toasts) {
            if (toastId !== undefined) {
                if (toast.toastId === toastId) {
                    toast.toastRef.manualClose();
                    return;
                }
            }
            else {
                toast.toastRef.manualClose();
            }
        }
    }
    remove(toastId) {
        const found = this._findToast(toastId);
        if (!found) {
            return false;
        }
        found.activeToast.toastRef.close();
        this.toasts.splice(found.index, 1);
        this.currentlyActive = this.currentlyActive - 1;
        if (!this.toastrConfig.maxOpened || !this.toasts.length) {
            return false;
        }
        if (this.currentlyActive <= +this.toastrConfig.maxOpened && this.toasts[this.currentlyActive]) {
            const p = this.toasts[this.currentlyActive].toastRef;
            if (!p.isInactive()) {
                this.currentlyActive = this.currentlyActive + 1;
                p.activate();
            }
        }
        return true;
    }
    isDuplicate(message) {
        for (let i = 0; i < this.toasts.length; i++) {
            if (this.toasts[i].message === message) {
                return true;
            }
        }
        return false;
    }
    applyConfig(override = {}) {
        function use(source, defaultValue) {
            return override && source !== undefined ? source : defaultValue;
        }
        const current = Object.assign({}, this.toastrConfig);
        current.closeButton = use(override.closeButton, current.closeButton);
        current.extendedTimeOut = use(override.extendedTimeOut, current.extendedTimeOut);
        current.progressBar = use(override.progressBar, current.progressBar);
        current.timeOut = use(override.timeOut, current.timeOut);
        current.enableHtml = use(override.enableHtml, current.enableHtml);
        current.toastClass = use(override.toastClass, current.toastClass);
        current.positionClass = use(override.positionClass, current.positionClass);
        current.titleClass = use(override.titleClass, current.titleClass);
        current.messageClass = use(override.messageClass, current.messageClass);
        current.tapToDismiss = use(override.tapToDismiss, current.tapToDismiss);
        current.toastComponent = use(override.toastComponent, current.toastComponent);
        current.onActivateTick = use(override.onActivateTick, current.onActivateTick);
        return current;
    }
    _findToast(toastId) {
        for (let i = 0; i < this.toasts.length; i++) {
            if (this.toasts[i].toastId === toastId) {
                return { index: i, activeToast: this.toasts[i] };
            }
        }
        return null;
    }
    _buildNotification(toastType, message, title, config) {
        if (!config.toastComponent) {
            throw new Error('toastComponent required');
        }
        if (message && this.toastrConfig.preventDuplicates && this.isDuplicate(message)) {
            return null;
        }
        this.previousToastMessage = message;
        let keepInactive = false;
        if (this.toastrConfig.maxOpened && this.currentlyActive >= this.toastrConfig.maxOpened) {
            keepInactive = true;
            if (this.toastrConfig.autoDismiss) {
                this.clear(this.toasts[this.toasts.length - 1].toastId);
            }
        }
        const overlayRef = this.overlay.create(config.positionClass, this.overlayContainer);
        this.index = this.index + 1;
        let sanitizedMessage = message;
        if (message && config.enableHtml) {
            sanitizedMessage = this.sanitizer.sanitize(SecurityContext.HTML, message);
        }
        const toastRef = new ToastRef(overlayRef);
        const toastPackage = new ToastPackage(this.index, config, sanitizedMessage, title, toastType, toastRef);
        const ins = {
            toastId: this.index,
            message,
            toastRef,
            onShown: toastRef.afterActivate(),
            onHidden: toastRef.afterActivate(),
            onTap: toastPackage.onTap(),
            onAction: toastPackage.onAction(),
        };
        const toastInjector = new ToastInjector(toastPackage, this._injector);
        const component = new ComponentPortal(config.toastComponent, toastInjector);
        ins.portal = overlayRef.attach(component, this.toastrConfig.newestOnTop);
        if (!keepInactive) {
            setTimeout(() => {
                ins.toastRef.activate();
                this.currentlyActive = this.currentlyActive + 1;
            });
        }
        this.toasts.push(ins);
        return ins;
    }
}
ToastrService.decorators = [
    { type: Injectable },
];
ToastrService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [TOAST_CONFIG,] },] },
    { type: Overlay, },
    { type: Injector, },
    { type: DomSanitizer, },
];
//# sourceMappingURL=toastr-service.js.map